#!/usr/bin/perl

##########################################################################################################
#filter.pl
# Attempts to resolve issues with sRNA annotation with profile HMMs such as:
#		- Duplicate annotations due to
#			- degenerate sequences
#			- sequences similar to terminators
#			- sequences that are their own reverse complements
#		- Paralogs hitting each other 
#		- Palindromic sequences hitting themselves
#		- Hellish combinations of all of the above
# Takes 2 gff files, one of sRNA annotations and one containing annotations of flanking regions
# Flanking regions are used as synteny anchors to guess which is the best annotation
##########################################################################################################

use strict;
use warnings;
use Getopt::Long;
use List::Util qw[min max];

my ($sRNA_annotations,$flank_annotations,$help);

&GetOptions(
	"1|file1=s"	=>	\$sRNA_annotations,
	"2|file2=s"	=>	\$flank_annotations,
	"h|help"	=>	\$help,
	);


#read in each annotation file and create data structure
my %genomes;
makeHash(\%genomes,$sRNA_annotations);

my %flank;
makeHash(\%flank,$flank_annotations);

foreach my $genome (keys %genomes){
	my %no_dupl;
	my %duplicates;
	my %overlaps;
	#find genes with multiple annotations, store in %duplicates. put other genes in %overlaps for testing
	foreach my $gene (keys %{$genomes{$genome}}){
		if (defined $genomes{$genome}{$gene}[1]){
			$duplicates{$gene}=1;
		}
		else{
		     	push @{ $overlaps{$genome} }, @{ $genomes{$genome}{$gene} };
		}
	}
	my %overlaps_1;
	#if annotation has no duplicates but overlaps with annotations from another gene, add to %overlaps_1
	if(defined @{ $overlaps{$genome} }[0]){
		@{ $overlaps{$genome} } = sort{$a->{'strand'} cmp $b->{'strand'} or $a->{'start'} <=> $b->{'start'}} @{ $overlaps{$genome} };
		#return list of annotations which overlap with other genes
		%overlaps_1 = overlapTest2(@{ $overlaps{$genome} }); 
	}
	foreach my $gene (keys %{$genomes{$genome}}){
		#if no overlaps and no duplicates, print annotation
		if((!(defined $overlaps_1{$gene})) && (!(defined $duplicates{$gene}))){ 
			print $genomes{$genome}{$gene}[0]->{'line'};
		}
		#if duplicates but no overlaps, find best duplicate with duplicateTest and print	
		elsif(defined $duplicates{$gene} && (!(defined $overlaps_1{$gene})) ){ 
			my $final = duplicateTest($genome,$gene);
			print $final;
		}
		else{
			#if annotation has duplicates and overlaps with other genes, find best duplicate with duplicateTest
			my $final = duplicateTest($genome,$gene); 
			my @fields = split('\t',$final);
			#add best duplicate to $overlaps_1 for testing	
			push @{ $overlaps_1{$genome} },{
					'line'=> $final,	
					'seqname'=> $fields[0],
					'source' => $fields[1],
					'feature' => $fields[2],
					'start' => $fields[3],
					'end' => $fields[4],
					'bitscore' => $fields[5],
					'strand' => $fields[6],
					'frame' => $fields[7],
					'attributes' => $fields[8]
				};
		}			
	}			
	#resolve overlaps between genes with overlapTest
	if (defined @{ $overlaps_1{$genome} }[1]){
		my @sort = sort{$a->{'strand'} cmp $b->{'strand'} or $a->{'start'} <=> $b->{'start'}} @{ $overlaps_1{$genome} };
		if (defined $sort[1]){
			@sort = overlapTest(@sort);
		}
		foreach (@sort){
		print $_->{'line'};
		}
	}
}

##################################################################################################
#put gff results into a data structure (hash of hashes of hashes of arrays)
#each genome has its own hash, containing separate hashes for each sRNA. 
#each gene hash contains an array of hashrefs containing field info from the gff 
#ex. 
#	genome
#		--> gene
#			--> array [0] hashref
#					--> start
#					--> end
#					--> strand etc
#			--> array [1] hashref
#					--> start
#					--> end
#					--> strand etc
##################################################################################################

sub makeHash{
	my($hash,$file) = @_;
	open(my $fh, '<', $file) or die "Cannot open file $file\n";
	while(<$fh>){
		if($_=~/^(\w+\d+)\t\S+\t(\S+)\t/){
			my $genome = $1;
			my $gene = $2;
			my @fields = split('\t',$_);	
			push @{ $$hash{$genome}{$gene} },{
					'line'=> $_,	
					'seqname'=> $fields[0],
					'source' => $fields[1],
					'feature' => $fields[2],
					'start' => $fields[3],
					'end' => $fields[4],
					'bitscore' => $fields[5],
					'strand' => $fields[6],
					'frame' => $fields[7],
					'attributes' => $fields[8]
				};
		}
	}
	close($fh);
}



#takes sorted gff annotations for a whole genome (one per gene) in @sorted (generated by sortGff)
#returns hash of genes with overlapping annotations %overlapgenes. 

sub overlapTest2{
	my @sorted = @_;
	my $sortedlines = @sorted;
	my %overlapgenes;
	for (my $z=1; $z < $sortedlines; $z++){
			my @a = split("\t", $sorted[$z]->{'line'});
			my @b = split("\t",$sorted[$z-1]->{'line'});
			if($a[6] eq $b[6] && $a[3] <= $b[4]){
				$overlapgenes{$a[2]} = 1;
				$overlapgenes{$b[2]} = 1;
			}				
	}
	return %overlapgenes;
}

#takes sorted gff annotations in @sorted (generated by sortGff)
#returns non-overlapping annotations

sub overlapTest{
	my @sorted = @_;
	my $sortedlines = @sorted;
	for (my $z=1; $z < $sortedlines; $z++){
			#compare adjacent lines in array
			my @a = split("\t", $sorted[$z]->{'line'});
			my @b = split("\t",$sorted[$z-1]->{'line'});
			#if lines are on same strand and overlapping
			if($a[6] eq $b[6] && $a[3] <= $b[4]){
				#if BELOW score > ABOVE score, remove ABOVE line from array, reset loop		
				if($a[5]>$b[5]){
					splice @sorted,$z-1,1;
					$z = 1;
					$sortedlines = @sorted;					
				}
				else{
					#if ABOVE score > BELOW score, remove BELOW line from array, reset loop
					splice @sorted,$z,1;
					$z = 1;
					$sortedlines = @sorted;
				}
				if($sortedlines > $z){
					redo;
				}
			  }
	}
	return @sorted;
}

#merges overlapping gff annotations of the same gene
sub collapseGff{
	my @sort =@_;
	my $sortedlines = @sort;
	for (my $z=1; $z <= $sortedlines-1; $z++){
			#compare adjacent lines in array
			my @a = split('\t', $sort[$z]->{'line'});
			my @b = split('\t',$sort[$z-1]->{'line'});
			#if lines are on same strand and overlapping, merge annotations
			if($a[6] eq $b[6] && $a[3] <= $b[4]){
				$a[3]=$b[3];
				$sort[$z]->{'start'} = $a[3];
				#take highest bitscore for the new annotation 
				$a[5] = max($a[5],$b[5]); 
				$sort[$z]->{'bitscore'} = $a[5];
				$a[4] = max($a[4],$b[4]);
				$sort[$z]->{'end'} = $a[4];
				$sort[$z]->{'line'} = join("\t",@a);
				#remove BELOW line from array, reset loop
				splice @sort,($z-1),1;
				$z = $z-1;
				$sortedlines = @sort;
			  }
	}
	return @sort;
}



#################################################################################################################################################################################
#flankTest:
#find the best scoring result in sorted annotations (@sorted) - containing both gene and flanking region annotations
#to resolve duplicate annotations (eg if your gene hits a common domain or motif a lot), flanking regions are used as synteny anchors to make sure the gene is in the right place
#if the flanking regions are within 150 nt and on the same strand, their bitscore is added. the annotation with the highest score wins.
#example:
#		gene		strand	score	start	end
# 		gene_A		+	54	200	400
#		left_flank	+	20	350	400		###
#		gene_A		+	30	420	500	 <- This annotation wins
#		right_flank	+	20	550	600		###
#		gene_A		-	65	420	500
##################################################################################################################################################################################

sub flankTest{
	my ($gene, $flank1, $flank2, @sort) = @_;
	my $sortedlines = @sort;
	my $score=0;
	my $final;
	for (my $z=1; $z <= $sortedlines-1; $z++){			
	               	my @middle = split('\t', $sort[$z]->{'line'});
			my @above = split('\t',$sort[$z-1]->{'line'});
			if ($middle[2] eq $gene){
				my $tempscore = $sort[$z]->{'bitscore'}; #default score 
				#if flank 1 upstream, add to score
				if($above[6] eq $middle[6] && $above[2] eq $flank1 && ($middle[3] - $above[4]) < 150){
					$tempscore = $tempscore + $above[5];
				}
				#if flank 2 upstream, add to score
				if($z<$sortedlines-1){
					my @below = split('\t',$sort[$z+1]->{'line'});
					if ($below[6] eq $middle[6] && $below[2] eq $flank2 && ($below[3] - $middle[4]) < 150){	
						$tempscore = $tempscore + $below[5];						
						}
				}
				if ($tempscore>$score){
					$score = $tempscore;
					$final = $sort[$z]->{'line'};
				}
			}
	}
	return $final;	
}

#######
#duplicateTest:
#Performs 3 operations to select the best result for genes with multiple annotations
#	1. Sorts annotations for given gene in a genome. Merges overlapping annotations with collapseGff
#	2. If any duplicates remain after step 1, add flanking region annotations and sort by start/strand.
#	3. If flanking annotations exist and have been included, run flankTest to find best result. Otherwise, take result with the highest bitscore.

sub duplicateTest{
	my ($genome,$gene)= @_;
	#sort annotations by strand and start
	my @sort = sort{$a->{'strand'} cmp $b->{'strand'} or $a->{'start'} <=> $b->{'start'}} @{ $genomes{$genome}{$gene} };
	#resolve overlaps within duplicates
	if(defined $sort[1]){
		@sort = collapseGff(@sort); 
	}
	my $final;
	#combine gene annotations and flanking region annotations in @flanksort. Sort by strand and start
	if(defined $sort[1]){
		#Naming convention for flanking genes. make option for these
		my $flank1 = $gene."_1.fasta"; 
		my $flank2 = $gene."_2.fasta";
		my @flanksort;
		#Add gene annotations to @flanksort. If flank annotations exist, add to flanksort
		#Lots of loops to get around autovivification differences in perl versions.
		if (defined @{ $flank{$genome}{$flank1} }[0] && defined @{ $flank{$genome}{$flank2} }[0]){
			@flanksort = sort{$a->{'strand'} cmp $b->{'strand'} or $a->{'start'} <=> $b->{'start'}} @sort,@{ $flank{$genome}{$flank1} },@{ $flank{$genome}{$flank2} };
			}
		elsif(defined @{ $flank{$genome}{$flank1} }[0] && not defined @{ $flank{$genome}{$flank2} }[0]){
			@flanksort = sort{$a->{'strand'} cmp $b->{'strand'} or $a->{'start'} <=> $b->{'start'}} @sort,@{ $flank{$genome}{$flank1} };
			}
		elsif(defined @{ $flank{$genome}{$flank2} }[0] && not defined @{ $flank{$genome}{$flank1} }[0]){
			@flanksort = sort{$a->{'strand'} cmp $b->{'strand'} or $a->{'start'} <=> $b->{'start'}} @sort,@{ $flank{$genome}{$flank2} };
			}
		#If no flanking annotations, take annotation with the highest bitscore
		else{
			#print "I have no flanks.\n";
			#foreach (@sort){
			#	print $_->{'line'};
			#}
			#print "now to test bitscore\n";
			@flanksort = sort{$a->{'bitscore'} <=> $b->{'bitscore'}} @sort;
			#foreach (@flanksort){
			#	print $_->{'line'};
			#}
			$final = $flanksort[-1]->{'line'};
			#print $final;
			}
		#If there are flanking annotations, get best result with flankTest			
		if(not defined $final){
			$final = flankTest($gene,$flank1,$flank2,@flanksort);
			}
	}
	#If only one annotaion is returned by collapseGff, return annotation
	else{
		$final = $sort[0]->{'line'};
		}	

	return $final;
}

